% abnTeX2: Modelo de Relatório Técnico/Acadêmico em conformidade com 
% ABNT NBR 10719:2015 Informação e documentação - Relatório técnico e/ou
% científico - Apresentação
% ------------------------------------------------------------------------ 
% ------------------------------------------------------------------------
\documentclass[
	% -- opções da classe memoir --
	12pt,				% tamanho da fonte
	openany,
	%twoside,			% para impressão em recto e verso. Oposto a oneside
	a4paper,			% tamanho do papel. 
	% -- opções da classe abntex2 --
	%chapter=TITLE,		% títulos de capítulos convertidos em letras maiúsculas
	%section=TITLE,		% títulos de seções convertidos em letras maiúsculas
	%subsection=TITLE,	% títulos de subseções convertidos em letras maiúsculas
	%subsubsection=TITLE,% títulos de subsubseções convertidos em letras maiúsculas
	% -- opções do pacote babel --
	english,			% idioma adicional para hifenização
	french,				% idioma adicional para hifenização
	spanish,			% idioma adicional para hifenização
	brazil,				% o último idioma é o principal do documento
	]{abntex2}
	
	
	
% PACOTES

% ---
% Pacotes fundamentais 
\usepackage{lmodern}			% Usa a fonte Latin Modern
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
\usepackage{color}				% Controle das cores
\usepackage{graphicx}			% Inclusão de gráficos
\usepackage{microtype}
\usepackage{url} 			% para melhorias de justificação
% ---

% Pacotes adicionais, usados no anexo do modelo de folha de identificação
\usepackage{multicol}
\usepackage{multirow}

\usepackage{float} % para utilizar o H de tabelas e figuras e mante-las no lugar


%----------------- PARA INSERIR ARQUIVOS DE CODIGOS -----------------%
\usepackage{xcolor}
% Definindo novas cores
	%\definecolor{verde}{rgb}{0,0.5,0}
% Configurando layout para mostrar codigos C++
\usepackage{listings}
\lstset{
  language=Verilog, %indicar a linguagem utilizada
  basicstyle=\ttfamily\tiny, 
  keywordstyle=\color{blue}, 
  stringstyle=\color{verde}, 
  commentstyle=\color{gray}, 
  extendedchars=true, 
  showspaces=false, 
  showstringspaces=false, 
  numbers=left,
  numberstyle=\tiny,
  breaklines=true, 
  backgroundcolor=\color{green!10},
  breakautoindent=true, 
  captionpos=b,
  xleftmargin=0pt,
}

% -----------------% FIM INSERIR ARQUIVOs DE CODIGO -----------------%

% Pacotes de citações
\usepackage[brazilian,hyperpageref]{backref}	 % Paginas com as citações na bibl
\usepackage[num]{abntex2cite}	% Citações padrão ABNT
\citebrackets() %citação numérica entre colchetes
% --- 

% CONFIGURAÇÕES DE PACOTES

% Configurações do pacote backref
% Usado sem a opção hyperpageref de backref
\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
% Texto padrão antes do número das páginas
\renewcommand{\backref}{}
% Define os textos da citação
% ---

% Informações de dados para CAPA e FOLHA DE ROSTO
\titulo{Relatório do Primeiro Trabalho em Grupo
\\ Estudo de Algoritmos de Ordenação}
\autor{Gustavo Barbaro de Oliveira
        \\ Vinícius Rodrigues Miguel}
\local{São José dos Campos - Brasil}
\data{Abril de 2019}
\instituicao{
  Docente: Prof. Dr. Reginaldo Massanobu Kuroshu
  \par
  Universidade Federal de São Paulo - UNIFESP
  \par
  Instituto de Ciência e Tecnologia - Campus São José dos Campos
}
\tipotrabalho{Relatório técnico}
\preambulo{Relatório apresentado à Universidade Federal de São Paulo como parte dos requisitos para aprovação na disciplina de Algortimos e Estruturas de Dados II.}
% ---

% informações do PDF
\makeatletter
\hypersetup{
     	%pagebackref=true,
		pdftitle={\@title}, 
		pdfauthor={\@author},
    	pdfsubject={\imprimirpreambulo},
	    pdfcreator={LaTeX with abnTeX2},
		pdfkeywords={abnt}{latex}{abntex}{abntex2}{relatório técnico}, 
		colorlinks=true,       		% false: boxed links; true: colored links
    	linkcolor=black,          	% color of internal links
    	citecolor=blue,        		% color of links to bibliography
    	filecolor=magenta,      		% color of file links
		urlcolor=blue,
		bookmarksdepth=4
}
\makeatother
% --- 

% Espaçamentos entre linhas e parágrafos 

% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip

% compila o indice
\makeindex
% ---

%inicio do documento
\begin{document}

% Seleciona o idioma do documento (conforme pacotes do babel)
%\selectlanguage{english}
\selectlanguage{brazil}

% Retira espaço extra obsoleto entre as frases.
\frenchspacing 

% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
% \pretextual


% ---
% Capa
\imprimircapa
% ---

% ---
% Folha de rosto
\imprimirfolhaderosto*


%------LISTAS SÃO OPCIONAIS---------
% inserir lista de ilustrações
%\pdfbookmark[0]{\listfigurename}{lof}
%\listoffigures*
%\clearpage

% inserir lista de tabelas
\pdfbookmark[0]{\listtablename}{lot}
\listoftables*
\clearpage
% ---

%SUMÁRIO É OBRIGATÓRIO
% inserir o sumario
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
% ---
% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
\textual

% ----------------------------------------------------------

\chapter{Geração de Conjuntos de Entrada}
    Para que fosse possível que todos os algoritmos recebessem um mesmo \textit{input}, foi projetado um \textit{script} na linguagem \textit{Go}. De início, este gerava arquivos com números aleatórios no intervalo $[-2.000.000.000, 2.000.000.000]$. Percebe-se, porém, que este intervalo traria uma performance péssima para os algoritmos com complexidade assintótica dependente de k como o Radix Sort e o Counting Sort.
    
    A fim de reduzir a amplitude dos números gerados, foi-se reprojetado o \textit{script} para que este gerasse números nos seguintes intervalos, sendo n a quantidade de números a serem gerados:
    \begin{enumerate}
	    \item Para gerar números aleatórios sem ordem, adota-se o intervalo de [$0, \left \lfloor{n/ln(ln(n))}\right \rfloor $]
	    \item Para a geração de números aleatórios ambos em ordem crescente e decrescente, adota-se o intervalo de [$2, \left \lfloor{log2(log2(log2(n)))}\right \rfloor $]. A geração de números em ordem decrescente tem sempre como valor máximo n/2  ou n/2 - 1.
\end{enumerate}

\chapter{Grupo I: Selection, Insertion}
    \section{Insertion Sort}
    
    	Considerado como um dos algoritmos de ordenação mais simples, o Insertion sort se baseia na ideia de inserção de um elemento em um subvetor ordenado, de maneia análoga à maneira pela qual cartas são comumente ordenadas. O algoritmo é especialmente útil quando tem-se um vetor semi-ordenado. 
    
    	\subsection{Resultados}
    	
    	Após as execuções, foram obtidos os seguintes resultados mostrados na Tabela \ref{tab:insertion}.
    	
    	\begin{table}[htb]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
Insertion & \multicolumn{3}{c|}{Tempo}                             \\ \hline
Entradas  & Crescente    & Decrescente        & Aleatório          \\ \hline
1.000     & 0.035000 ms  & 4.811000 ms        & 3.576000 ms        \\ \hline
10.000    & 0.140000 ms  & 464.450000 ms      & 231.219000 ms      \\ \hline
100.000   & 1.338000 ms  & 46641.708000 ms    & 23348.745000 ms    \\ \hline
1.000.000 & 13.318000 ms & 43934837.230000 ms & 22344492.745000 ms \\ \hline
\end{tabular}
\caption{Insertion Sort com os tempos de execução}
\label{tab:insertion}
\end{table}
    
    Pode-se perceber o comportamento quadrático da Ordenação por Inserção, isto é, o tempo de execução cresce de maneira sempre quadrática ao tamanho de entrada, salvo nos casos onde os elementos já estão ordenados crescentemente.
        
    \section{Selection Sort}
    
    A ordenação por seleção consiste em percorrer o vetor, encontrar seu menor valor,  substituí-lo na posição inicial do vetor, após feito isso, incrementa-se uma posição e o o laço inicia novamente procurando o o segundo menor valor, para colocar na segunda posição do vetor, e assim sucessivamente.
    
    	\subsection{Resultados}
    	Após as execuções, foi-se obtido os seguintes resultados mostrados na Tabela \ref{tab:selection}.
    	
    	\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
Selection & \multicolumn{3}{c|}{Tempo}                             \\ \hline
Entradas  & Crescente        & Decrescente       & Aleatório       \\ \hline
1.000     & 4.2215 ms        & 11.6235 ms        & 10.138 ms       \\ \hline
10.000    & 370.118000 ms    & 1106.134000 ms    & 772.293 ms      \\ \hline
100.000   & 37280.069000 ms  & 113334.024000 ms  & 75700.552000 ms \\ \hline
1.000.000 & \multicolumn{3}{c|}{Em teoria, levará mais de 2 horas} \\ \hline
\end{tabular}
\caption{Selection Sort com os tempos de execução}
\label{tab:selection}
\end{table}
    
    Assim como o Insertion, o Selection apresenta um crescimento quadrático ainda mais grave, tendo ainda a desvantagem de continuar sendo $\mathcal{O}(n^2)$ até para o caso de vetor já ordenado.
    
\chapter{Grupo II: Quick, Merge}

	\section{Quick Sort}
	
	Um dos algoritmos normalmente eficiente, o Quick Sort utiliza a técnica da divisão e conquista para rearranjar as chaves do vetor de modo que as chaves menores precedam as chaves maiores. Em seguida ele ordena as duas sub-listas de chaves menores e maiores recursivamente até que a lista fique ordenada.
	
	\subsection{Resultados}
   	Após as execuções, foi-se obtido os seguintes resultados mostrados na Tabela \ref{tab:quick}.
   	
   	\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
Quick     & \multicolumn{3}{c|}{Tempo}                           \\ \hline
Entradas  & Crescente        & Decrescente      & Aleatório      \\ \hline
1.000     & 9.920000 ms.     & 4.578000 ms.     & 0.225000 ms.   \\ \hline
10.000    & 818.878000 ms.   & 370.852000 ms.   & 2.377000 ms.   \\ \hline
100.000   & 83050.890000 ms. & 35541.581000 ms. & 30.312000 ms.  \\ \hline
1.000.000 & Demora muito.    & Demora muito.    & 357.496000 ms. \\ \hline
\end{tabular}
\caption{Quick Sort com os tempos de execução.}
\label{tab:quick}
\end{table}
	
	O algoritmo de Ordenação por Partição demonstra um funcionamento rápido para valores desordenados, levando, para estes casos, cerca de metade do tempo levado pelo Merge Sort para os mesmos valores.
	O algoritmo, no entanto, aparenta funcionamento péssimo quando os valores estão ordenados, seja crescente ou decrescentemente, apresentando nestes casos um funcionamento ainda pior em relação ao Insertion Sort e Selection Sort.
	
	
	\section{Merge Sort}
	O merge sort é um outro exemplo de algoritmo bastante otimizado que se utiliza da técnica de dividir para conquistar. De forma bastante semelhante ao quick sort, utiliza chamadas recursivas para conseguir particionar um problema grande em outros pequenos, de fácil solução.
	
	Os três passos fundamentais desse algoritmo são : 
	
	\begin{itemize}
		\item Dividir: Calcula o ponto médio do vetor para fazer a primeira divisão.
		\item Conquistar: Utilizando chamadas recursivas, resolve dois subproblemas cada um de tamanho $\frac{N}{2}$
		\item Combinar: Unir os dois sub arranjos em um único conjunto ordenado.
	\end{itemize}
	
	\subsection{Resultados}
	   	Após as execuções, foi-se obtido os seguintes resultados mostrados na Tabela \ref{tab:merge}.
	   	
	  \begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
Merge & \multicolumn{3}{c|}{Tempo} \\ \hline
Entradas & Crescente & Decrescente & Aleatório \\ \hline
1.000 & 0.425000 ms. & 0.578 ms. & 0.835000 ms. \\ \hline
10.000 & 3.765000 ms. & 4.050200 ms. & 4.472000 ms. \\ \hline
100.000 & 42.759000 ms. & 43.512000 ms. & 52.329000 ms. \\ \hline
1.000.000 & 490.260000 ms. & 496.719000 ms. & 602.378000 ms. \\ \hline
\end{tabular}
\caption{Merge Sort com os tempos de execução.}
\label{tab:merge}
\end{table}

    % Comentário de funcionamento do Merge
    
    Embora tenha um funcionamento de Caso Médio pior em comparação ao Quick Sort, o Merge apresenta maior equilíbrio no sentido de que este funciona de maneira similar para qualquer tipo de valores de entrada, estejam ele caóticos, quase-ordenados ou ordenados, diferentemente do Quick. 
    
\chapter{Grupo III: Counting, Radix}
    \section{Counting Sort}
	
	% Descrição do funcionamento do Counting
	
	O Counting Sort é um algoritmo não-comparativo, cujo funcionamento resumido se dá por contar o número de itens distintos e então calculando a posição final destes na ordem de saída. O Counting é eficiente quando o alcance (\textit{range}) dos dados de entrada não é significantemente maior do que o número de itens a serem ordenados. Ele costuma ser utilizado como sub-rotina para outros algoritmos de ordenação, tais como o Radix Sort.
	
	\subsection{Resultados}
	Após as execuções, foi-se obtido os seguintes resultados mostrados na Tabela \ref{tab:counting}.
	
	\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
Counting & \multicolumn{3}{c|}{Tempo} \\ \hline
Entradas & Crescente & Decrescente & Aleatório \\ \hline
1.000 & 0.034000 ms. & 0.047000 ms. & 0.056000 ms. \\ \hline
10.000 & 0.425000 ms. & 0.494000 ms. & 0.385000 ms. \\ \hline
100.000 & 4.312000 ms. & 3.210000 ms. & 5.210000 ms \\ \hline
1.000.000 & 32.421000 ms. & 28.201000 ms. & 27.581000 ms. \\ \hline
\end{tabular}
\caption{Counting Sort com os tempos de execução.}
\label{tab:counting}
\end{table}
	
	% Comentário de funcionamento do Counting
	
	 A natureza de ordem linear do Counting Sort se demonstrou forte nas simulações feitas, visto que este obteve resultados muito melhores do que obtiveram os algoritmos comparativos testados até o momento, sendo eficiente até para os casos-teste de um milhão de valores, visto que o \textit{script} em \textit{Go} cria valores máximos em torno de n/2 (k = 500.000 quando n = 1.000.000).
	
	\section{Radix Sort}

    % Comentário de funcionamento do Radix

    O Counting sort é bem eficiente para ordenar vetores cujo tamanho, $ \mathtt{n}$, não é muito menor que o tamanho máximo do vetor, $ \ensuremath{\mathtt{k}}$. O algoritmo Radix Sort utiliza diversas chamadas de Counting-Sort para permitir um alcance (\textit{range}) maior de valores máximos.
    O Radix Sort ordena inteiros de w-bits ao chamar w/d chamadas de Counting Sort para ordenar esses inteiros, d bits de cada vez.
    

    \subsection{Resultados}
    Após as execuções, foi-se obtido os seguintes resultados mostrados na Tabela \ref{tab:radix}.
    
    \begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
Radix & \multicolumn{3}{c|}{Tempo} \\ \hline
Entradas & Crescente & Decrescente & Aleatório \\ \hline
1.000 & 0.040000 ms. & 0.040000 ms. & 0.042000 ms \\ \hline
10.000 & 0.455000 ms. & 0.344000 ms. & 0.345000 ms. \\ \hline
100.000 & 3.612000 ms. & 3.514000 ms. & 4.317000 ms. \\ \hline
1.000.000 & 35.995000 ms. & 34.837000 ms. & 85.824000 ms. \\ \hline
\end{tabular}
\caption{Radix Sort com os tempos de execução}
\label{tab:radix}
\end{table}
    
    % Comentário de funcionamento do Radix
    
    O segundo algoritmo não-comparativo a ser testado, o Radix Sort apresentou excelentes resultados para todos os casos-teste, similares aos resultados apresentados pelo Counting Sort, mesmo quando os valores de k foram destoantes do valor de n.
    
    
\chapter {Observações} % Considerações finais

Para a execução dos testes foi utilizado um computador com as seguintes configurações:
\begin{itemize}
    \item Ubuntu MATE 16.04
    \item Unix Kernel 4.15.0-47
    \item GCC 5.4.0
    \item Go 1.12.1
    \item Processador i3-6006U
    \item 4GB RAM
\end{itemize}

De modo geral, identificamos que o Quick Sort apresentou o melhor tempo de execução de caso médio, o Merge Sort o melhor balanço dentre os modos de ordenação dos valores de entrada, o Insertion um bom funcionamento para valores ordenados/quase-ordenados e Radix/Counting excelentes resultados de tempo, embora com condições adicionais para bom funcionamento.

\end{document}
